use std::collections::HashMap;

use heck::CamelCase;
use icu_locid::LanguageIdentifier;
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;

use crate::{
    parser::{TranslationData, TranslationKey},
    RosettaConfig,
};

pub(crate) fn generate(data: TranslationData, config: &RosettaConfig) -> TokenStream {
    // Languages as CamelCase strings
    let languages: Vec<_> = config
        .languages()
        .iter()
        .map(|lang| lang.to_string().to_camel_case())
        .collect();

    let name = Ident::new(&config.name, Span::call_site());
    let fields = languages
        .iter()
        .map(|lang| Ident::new(lang, Span::call_site()));

    let methods = data.keys.iter().map(|(key, value)| match value {
        TranslationKey::Simple { fallback, others } => method_simple(&name, key, fallback, others),
    });

    quote! {
        /// Language type generated by the [rosetta](https://github.com/baptiste0928/rosetta) i18n library.
        #[derive(Debug Clone, Copy, Eq, PartialEq)]
        pub enum #name {
            #(#fields),*
        }

        impl #name {
            #(#methods)*
        }
    }
}

/// Generate method for [`TranslationKey::Simple`]
fn method_simple(
    name: &Ident,
    key: &str,
    fallback: &str,
    others: &HashMap<LanguageIdentifier, String>,
) -> TokenStream {
    let method_name = Ident::new(key, Span::call_site());
    let arms = others
        .iter()
        .map(|(language, value)| match_arm_simple(name, language, value));

    quote! {
        pub fn #key(&self) -> &'static str {
            match self {
                #(#arms),*
                _ => #fallback
            }
        }
    }
}

/// Generate match arm for [`TranslationKey::Simple`]
fn match_arm_simple(name: &Ident, language: &LanguageIdentifier, value: &str) -> TokenStream {
    let lang = Ident::new(&language.to_string().to_camel_case(), Span::call_site());

    quote! { #name::#lang => #value }
}
