//! Code generation
//!
//! # Generated code
//! The generated code consists of a single enum (called by default `Lang`),
//! which expose public method for each of the translation keys. These
//! methods returns a `&'static str` where possible, otherwise a `String`.
//!
//! # Usage
//! The code generator is contained within the [`CodeGenerator`] struct.
//! Calling [`generate`](CodeGenerator::generate) will produce a [TokenStream]
//! with the generated code. Internal methods used to generate the output are not exposed.

use std::collections::HashMap;

use heck::{CamelCase, SnakeCase};
use icu_locid::LanguageIdentifier;
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;

use crate::{
    parser::{TranslationData, TranslationKey},
    RosettaConfig,
};

/// Type storing state and configuration for the code generator
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CodeGenerator<'a> {
    keys: &'a HashMap<String, TranslationKey>,
    languages: Vec<&'a LanguageIdentifier>,
    name: Ident,
}

impl<'a> CodeGenerator<'a> {
    /// Initialize a new [`CodeGenerator`]
    pub fn new(data: &'a TranslationData, config: &'a RosettaConfig) -> Self {
        let name = Ident::new(&config.name, Span::call_site());

        CodeGenerator {
            keys: &data.keys,
            languages: config.languages(),
            name,
        }
    }

    /// Generate code as a [`TokenStream`]
    pub fn generate(&self) -> TokenStream {
        // Transform as CamelCase strings
        let languages: Vec<_> = self
            .languages
            .iter()
            .map(|lang| lang.to_string().to_camel_case())
            .collect();

        let name = &self.name;
        let fields = languages
            .iter()
            .map(|lang| Ident::new(lang, Span::call_site()));

        let methods = self.keys.iter().map(|(key, value)| match value {
            TranslationKey::Simple { fallback, others } => {
                self.method_simple(key, fallback, others)
            }
        });

        quote! {
            /// Language type generated by the [rosetta](https://github.com/baptiste0928/rosetta) i18n library.
            #[derive(Debug, Clone, Copy, Eq, PartialEq)]
            pub enum #name {
                #(#fields),*
            }

            impl #name {
                #(#methods)*
            }
        }
    }

    /// Generate method for [`TranslationKey::Simple`]
    fn method_simple(
        &self,
        key: &str,
        fallback: &str,
        others: &HashMap<LanguageIdentifier, String>,
    ) -> TokenStream {
        let name = Ident::new(&key.to_snake_case(), Span::call_site());
        let arms = others
            .iter()
            .map(|(language, value)| self.match_arm_simple(language, value));

        quote! {
            #[allow(clippy::match_single_binding)]
            pub fn #name(&self) -> &'static str {
                match self {
                    #(#arms,)*
                    _ => #fallback
                }
            }
        }
    }

    /// Generate match arm for [`TranslationKey::Simple`]
    fn match_arm_simple(&self, language: &LanguageIdentifier, value: &str) -> TokenStream {
        let name = &self.name;
        let lang = Ident::new(&language.to_string().to_camel_case(), Span::call_site());

        quote! { #name::#lang => #value }
    }
}
