//! Code generation
//!
//! # Generated code
//! The generated code consists of a single enum (called by default `Lang`),
//! which expose pub(crate)lic method for each of the translation keys. These
//! methods returns a `&'static str` where possible, otherwise a `String`.
//!
//! # Usage
//! The code generator is contained within the [`CodeGenerator`] struct.
//! Calling [`generate`](CodeGenerator::generate) will produce a [TokenStream]
//! with the generated code. Internal methods used to generate the output are not exposed.

use std::collections::HashMap;

use convert_case::{Case, Casing};
use proc_macro2::{Ident, Span, TokenStream};
use quote::quote;

use crate::{
    config::RosettaConfig,
    parser::{TranslationData, TranslationKey},
    LanguageId,
};

/// Type storing state and configuration for the code generator
#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct CodeGenerator<'a> {
    keys: &'a HashMap<String, TranslationKey>,
    languages: Vec<&'a LanguageId>,
    name: Ident,
}

impl<'a> CodeGenerator<'a> {
    /// Initialize a new [`CodeGenerator`]
    pub(crate) fn new(data: &'a TranslationData, config: &'a RosettaConfig) -> Self {
        let name = Ident::new(&config.name, Span::call_site());

        CodeGenerator {
            keys: &data.keys,
            languages: config.languages(),
            name,
        }
    }

    /// Generate code as a [`TokenStream`]
    pub(crate) fn generate(&self) -> TokenStream {
        // Transform as PascalCase strings
        let languages: Vec<_> = self
            .languages
            .iter()
            .map(|lang| lang.value().from_case(Case::Flat).to_case(Case::Pascal))
            .collect();

        let name = &self.name;
        let fields = languages
            .iter()
            .map(|lang| Ident::new(lang, Span::call_site()));

        let methods = self.keys.iter().map(|(key, value)| match value {
            TranslationKey::Simple { fallback, others } => {
                self.method_simple(key, fallback, others)
            }
        });

        quote! {
            /// Language type generated by the [rosetta](https://github.com/baptiste0928/rosetta) i18n library.
            #[derive(Debug, Clone, Copy, Eq, PartialEq)]
            pub(crate) enum #name {
                #(#fields),*
            }

            impl #name {
                #(#methods)*
            }
        }
    }

    /// Generate method for [`TranslationKey::Simple`]
    fn method_simple(
        &self,
        key: &str,
        fallback: &str,
        others: &HashMap<LanguageId, String>,
    ) -> TokenStream {
        let name = Ident::new(&key.to_case(Case::Snake), Span::call_site());
        let arms = others
            .iter()
            .map(|(language, value)| self.match_arm_simple(language, value));

        quote! {
            #[allow(clippy::match_single_binding)]
            pub(crate) fn #name(&self) -> &'static str {
                match self {
                    #(#arms,)*
                    _ => #fallback
                }
            }
        }
    }

    /// Generate match arm for [`TranslationKey::Simple`]
    fn match_arm_simple(&self, language: &LanguageId, value: &str) -> TokenStream {
        let name = &self.name;
        let lang = Ident::new(
            &language.value().from_case(Case::Flat).to_case(Case::Pascal),
            Span::call_site(),
        );

        quote! { #name::#lang => #value }
    }
}
